var Pe=Object.defineProperty;var Ae=(e,t,s)=>t in e?Pe(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s;var j=(e,t,s)=>(Ae(e,typeof t!="symbol"?t+"":t,s),s);import{b as oe,d as D,e as A,o as h,c as y,a as l,t as w,f as E,w as O,F as W,r as Y,T as He,n as H,g as R,h as z,i as U,j as ce,k as Z,l as Te,m as de,p as L,u as $e,q as re,s as J,v as Me,x as Ce}from"./index-ecf1f6b9.js";import{_ as N}from"./_plugin-vue_export-helper-c27b6911.js";var F=(e=>(e.GROUND="ground",e.WALL="wall",e.WATER="water",e.VOID="void",e))(F||{});const ne={ground:{isWalkable:!0,className:"normal"},wall:{isWalkable:!1,className:"obstacle"},water:{isWalkable:!1,className:"water"},void:{isWalkable:!1,className:"void"}};function ee(e,t){return{type:e,position:t,isWalkable:ne[e].isWalkable,isOccupied:!1}}var x=(e=>(e.WARRIOR="warrior",e.MAGE="mage",e.ARCHER="archer",e.SUPPORT="support",e.TANK="tank",e.ASSASSIN="assassin",e.HEALER="healer",e))(x||{}),I=(e=>(e.WARRIOR="warrior",e.MAGE="mage",e.ARCHER="archer",e.SUPPORT="support",e))(I||{});const B={move:2,skill:1,item:1},Ee={id:"basic_attack",name:"基础攻击",description:"近距离攻击，造成100%攻击力的伤害",icon:"/skills/basic_attack.png",mpCost:0,cooldown:0,currentCooldown:0,range:1,type:"active",targetType:"single",effect:(e,t)=>{if(!("stats"in t))return;const s=Math.max(1,e.stats.attack-t.stats.defense);m().applyDamage(t.id,s)}},Ie={id:"frost_nova",name:"霜华绽放",description:"释放寒冰能量，对范围内敌人造成120%魔法伤害并减速40%",icon:"/skills/frost_nova.png",mpCost:25,cooldown:2,currentCooldown:0,range:2,type:"active",targetType:"area",aoeRange:1,effect:async(e,t)=>{if(!Array.isArray(t))return;await new Promise(o=>setTimeout(o,300));const s=m();t.forEach(o=>{const n=Math.max(1,e.stats.attack*1.2-o.stats.defense);s.applyDamage(o.id,n),o.status.push({id:`frost_${Date.now()}`,name:"霜冻",description:"移动速度降低40%",icon:"/status/frost.png",duration:2,effect:{type:"debuff",stats:{speed:.4}}})})}},Oe={id:"ice_shield",name:"寒冰护盾",description:"为目标提供一个吸收70%伤害的护盾，并提升30%防御力",icon:"/skills/ice_shield.png",mpCost:20,cooldown:2,currentCooldown:0,range:3,type:"active",targetType:"single",effect:(e,t)=>{"stats"in t&&t.status.push({id:`shield_${Date.now()}`,name:"寒冰护盾",description:"防御力提升30%，减免70%伤害",icon:"/status/ice_shield.png",duration:2,effect:{type:"buff",stats:{defense:.3,damageReduction:.7}}})}},Re={id:"wind_slash",name:"风之斩击",description:"快速突进并造成180%攻击力的伤害，击中后获得1回合��速",icon:"/skills/wind_slash.png",mpCost:20,cooldown:2,currentCooldown:0,range:3,type:"active",targetType:"single",effect:(e,t)=>{if(!("stats"in t))return;const s=Math.max(1,e.stats.attack*1.8-t.stats.defense);m().applyDamage(t.id,s),e.status.push({id:`swift_${Date.now()}`,name:"疾风",description:"移动速度提升30%",icon:"/status/swift.png",duration:1,effect:{type:"buff",stats:{speed:.3}}})}},De={id:"sword_dance",name:"剑舞",description:"进入剑舞状态，提升50%攻击力和30%移动速度，持续2回合",icon:"/skills/sword_dance.png",mpCost:25,cooldown:3,currentCooldown:0,range:0,type:"active",targetType:"self",effect:e=>{e.status.push({id:`dance_${Date.now()}`,name:"剑舞",description:"攻击力提升50%，移动速度提升30%",icon:"/status/sword_dance.png",duration:2,effect:{type:"buff",stats:{attack:.5,speed:.3}}})}},Ne={id:"precise_shot",name:"精准射击",description:"对单一目标造成200%攻击力的伤害，如果目标生命值低于30%则必定暴击",icon:"/skills/precise_shot.png",mpCost:20,cooldown:2,currentCooldown:0,range:4,type:"active",targetType:"single",effect:(e,t)=>{if(!("stats"in t))return;let s=e.stats.attack*2-t.stats.defense;t.stats.hp<t.stats.maxHp*.3&&(s*=1.5),m().applyDamage(t.id,Math.max(1,s))}},Ge={id:"shadow_step",name:"影袭",description:"瞬移到目标位置并获得隐身效果，下次攻击造成150%伤害",icon:"/skills/shadow_step.png",mpCost:30,cooldown:2,currentCooldown:0,range:3,type:"active",targetType:"position",effect:(e,t)=>{"x"in t&&(e.position=t,e.status.push({id:`stealth_${Date.now()}`,name:"隐袭",description:"隐身状态，下次攻击伤害提升50%",icon:"/status/stealth.png",duration:1,effect:{type:"buff",stats:{attack:.5,stealth:1}}}))}},Ve={id:"nature_blessing",name:"自然祝福",description:"治疗目标30%最大生命值，并提供一个可以抵挡一次致命伤害的护盾",icon:"/skills/nature_blessing.png",mpCost:25,cooldown:2,currentCooldown:0,range:3,type:"active",targetType:"single",effect:(e,t)=>{if(!("stats"in t))return;const s=t.stats.maxHp*.3;t.stats.hp=Math.min(t.stats.maxHp,t.stats.hp+s),t.status.push({id:`blessing_${Date.now()}`,name:"生命护盾",description:"可以抵挡一次致命伤害",icon:"/status/blessing.png",duration:2,effect:{type:"buff",stats:{deathPrevention:!0}}})}},Le={id:"nature_fury",name:"自然之怒",description:"对范围内敌人造成伤害并施加易伤效果，使其受到的伤害提升40%",icon:"/skills/nature_fury.png",mpCost:35,cooldown:3,currentCooldown:0,range:3,type:"active",targetType:"area",aoeRange:2,effect:(e,t)=>{if(!Array.isArray(t))return;const s=m();t.forEach(o=>{const n=Math.max(1,e.stats.attack*1.2-o.stats.defense);s.applyDamage(o.id,n),o.status.push({id:`vulnerable_${Date.now()}`,name:"易伤",description:"受到的伤害提升40%",icon:"/status/vulnerable.png",duration:2,effect:{type:"debuff",stats:{damageReceived:.4}}})})}},se=[{id:"aurora",name:"极光",title:"冰霜编织者",description:"来自永冻之地的神秘法师，掌握着强大的冰霜魔法。",avatar:"/heroes/aurora/avatar.png",portrait:"/heroes/aurora/portrait.png",tags:[x.MAGE,x.SUPPORT],type:I.MAGE,level:1,exp:0,position:{x:0,y:0},stats:{hp:40,maxHp:40,mp:40,maxMp:40,attack:12,defense:4,speed:4},skills:[Ee,Ie,Oe],status:[],isAlly:!0,actionPoints:{...B},maxActionPoints:{move:2,skill:1,item:1}},{id:"blade_master",name:"剑魂",title:"追风剑豪",description:"流浪的剑客，一生追求剑道的极致。",avatar:"/heroes/blade_master/avatar.png",portrait:"/heroes/blade_master/portrait.png",tags:[x.WARRIOR,x.ASSASSIN],type:I.WARRIOR,level:1,exp:0,position:{x:0,y:0},stats:{hp:40,maxHp:40,mp:60,maxMp:60,attack:15,defense:6,speed:6},skills:[Re,De],status:[],isAlly:!0,actionPoints:{...B},maxActionPoints:{move:3,skill:1,item:1}},{id:"luna",name:"月影",title:"暗夜守护者",description:"神秘的暗夜精灵，擅长远程攻击和潜行。",avatar:"/heroes/luna/avatar.png",portrait:"/heroes/luna/portrait.png",tags:[x.ARCHER,x.ASSASSIN],type:I.ARCHER,level:1,exp:0,position:{x:0,y:0},stats:{hp:40,maxHp:40,mp:80,maxMp:80,attack:14,defense:3,speed:5},skills:[Ne,Ge],status:[],isAlly:!0,actionPoints:{...B},maxActionPoints:{move:3,skill:1,item:1}},{id:"gaia",name:"盖亚",title:"大地守护者",description:"自然之力的化身，守护着森林与生命。",avatar:"/heroes/gaia/avatar.png",portrait:"/heroes/gaia/portrait.png",tags:[x.SUPPORT,x.HEALER],type:I.SUPPORT,level:1,exp:0,position:{x:0,y:0},stats:{hp:40,maxHp:40,mp:120,maxMp:120,attack:8,defense:5,speed:4},skills:[Ve,Le],status:[],isAlly:!0,actionPoints:{...B},maxActionPoints:{move:3,skill:1,item:1}}],m=oe("hero",{state:()=>({heroes:new Map,selectedHeroId:null,activeHeroId:null,deadHeroes:new Set}),getters:{selectedHero:e=>e.selectedHeroId?e.heroes.get(e.selectedHeroId)??null:null,activeHero:e=>e.activeHeroId?e.heroes.get(e.activeHeroId)??null:null,allies:e=>Array.from(e.heroes.values()).filter(t=>t.isAlly),enemies:e=>Array.from(e.heroes.values()).filter(t=>!t.isAlly),aliveEnemiesCount:e=>Array.from(e.heroes.values()).filter(t=>!t.isAlly&&!e.deadHeroes.has(t.id)).length},actions:{initializeHeroes(){se.forEach(e=>{this.heroes.set(e.id,{...e})})},moveHero(e,t){const s=this.heroes.get(e);s&&(s.position=t)},addStatus(e,t){const s=this.heroes.get(e);s&&(s.status.push(t),this.applyStatusEffects(s))},removeStatus(e,t){const s=this.heroes.get(e);s&&(s.status=s.status.filter(o=>o.id!==t),this.applyStatusEffects(s))},applyStatusEffects(e){const t={...e.stats};e.status.forEach(s=>{Object.entries(s.effect.stats).forEach(([o,n])=>{const i=o;if(typeof n=="number"&&typeof e.stats[i]=="number"&&!["deathPrevention"].includes(i)){const r=t[i],g=n;e.stats[i]=s.effect.type==="buff"?r*(1+g):r*(1-g)}})}),e.stats.hp<=0&&!this.deadHeroes.has(e.id)&&(console.log(`[Death Check] ${e.name} HP is ${e.stats.hp}, triggering death`),this.handleHeroDeath(e.id))},handleHeroDeath(e){const t=this.heroes.get(e);if(!t){console.log(`[Death Handler] Hero ${e} not found`);return}console.log(`[Death Handler] Processing death of ${t.name} (${t.id})`),this.deadHeroes.add(e),this.selectedHeroId===e&&(console.log(`[Death Handler] Deselecting dead hero ${t.name}`),this.selectHero(null));const s=$();if(this.activeHeroId===e&&(console.log(`[Death Handler] Ending turn of dead hero ${t.name}`),s.endHeroTurn()),s.removeFromTurnOrder(e),!t.isAlly){const o=this.aliveEnemiesCount;console.log(`[Victory Check] Enemy died. Remaining enemies: ${o}`),o===0&&(console.log("[Victory Check] All enemies defeated! Triggering victory"),setTimeout(()=>{s.handleVictory()},100))}},selectHero(e){console.log("Selecting hero:",e),this.selectedHeroId=e,e||P().clearSelection()},setActiveHero(e){this.activeHeroId=e},updateHeroHealth(e,t){const s=this.heroes.get(e);s&&(console.log(`[Health] ${s.name} HP changing from ${s.stats.hp} to ${t}`),s.stats.hp=t,s.stats.hp<=0&&!this.deadHeroes.has(s.id)&&(console.log(`[Death Check] ${s.name} HP is ${s.stats.hp}, triggering death`),this.handleHeroDeath(s.id)))},applyDamage(e,t){const s=this.heroes.get(e);if(!s)return;console.log(`[Damage] ${s.name} 受到 ${t} 点伤害`);const o=Math.max(0,s.stats.hp-t);this.updateHeroHealth(e,o)},addHero(e){this.heroes.set(e.id,e)},$reset(){this.heroes.clear(),this.selectedHeroId=null,this.deadHeroes.clear()}}}),P=oe("board",{state:()=>({width:8,height:8,tiles:[],highlightedTiles:[],selectableTiles:[],selectedTile:void 0,currentMap:null}),actions:{initializeBoard(){this.tiles=Array(this.height).fill(null).map((e,t)=>Array(this.width).fill(null).map((s,o)=>ee(F.GROUND,{x:o,y:t})))},loadMap(e){this.width=e.width,this.height=e.height,this.currentMap=e,this.tiles=e.terrain.map((t,s)=>t.map((o,n)=>ee(o,{x:n,y:s}))),this.clearSelection()},selectTile(e){this.selectedTile=e},clearSelection(){this.selectedTile=void 0,this.highlightedTiles=[],this.selectableTiles=[]},setTileType(e,t){this.isValidPosition(e)&&(this.tiles[e.y][e.x],this.tiles[e.y][e.x]=ee(t,e))},highlightTiles(e){this.highlightedTiles=e},setSelectableTiles(e){this.selectableTiles=e},isValidPosition(e){return e.x>=0&&e.x<this.width&&e.y>=0&&e.y<this.height},calculateMovableRange(e,t){console.log("Calculating movable range:",{position:e,moveRange:t});const s=[],o=new Set,n=[{pos:e,steps:0}],i=r=>`${r.x},${r.y}`;for(;n.length>0;){const r=n.shift(),g=i(r.pos);if(!o.has(g)&&(o.add(g),r.steps<=t)){r.steps>0&&s.push(r.pos);const d=[{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}];for(const u of d){const c={x:r.pos.x+u.x,y:r.pos.y+u.y};this.isValidMovePosition(c)&&n.push({pos:c,steps:r.steps+1})}}}return console.log("Calculated movable positions:",s),s},isValidMovePosition(e){if(!this.isValidPosition(e))return!1;const t=this.tiles[e.y][e.x];if(!ne[t.type].isWalkable)return!1;const s=m();return!Array.from(s.heroes.values()).some(o=>o.position.x===e.x&&o.position.y===e.y)},$reset(){this.width=8,this.height=8,this.tiles=[],this.highlightedTiles=[],this.selectableTiles=[],this.selectedTile=void 0,this.currentMap=null}}});var T=(e=>(e.ALLY="ally",e.ENEMY="enemy",e.NEUTRAL="neutral",e))(T||{}),q=(e=>(e.PREPARE="prepare",e.ACTION="action",e.END="end",e))(q||{});const K={move:1,skill:1,item:1},Q={id:"basic_attack",name:"基础攻击",description:"近距离攻击",icon:"/skills/basic_attack.png",mpCost:0,cooldown:0,currentCooldown:0,range:1,type:"active",targetType:"single",effect:(e,t)=>{if(!("stats"in t))return;const s=Math.max(1,e.stats.attack-t.stats.defense);m().applyDamage(t.id,s)}},Be={id:"shadow_strike",name:"暗影突袭",description:"快速突进并造成高额伤害",icon:"/skills/shadow_strike.png",mpCost:30,cooldown:2,currentCooldown:0,range:3,type:"active",targetType:"single",effect:(e,t)=>{if(!("stats"in t))return;const s=Math.max(1,e.stats.attack*1.5-t.stats.defense);m().applyDamage(t.id,s)}},Ue={id:"dark_bolt",name:"暗影法球",description:"发射暗影能量球造成范围伤害",icon:"/skills/dark_bolt.png",mpCost:35,cooldown:2,currentCooldown:0,range:3,type:"active",targetType:"area",aoeRange:1,effect:(e,t)=>{if(!Array.isArray(t))return;const s=m();t.forEach(o=>{const n=Math.max(1,e.stats.attack*.8-o.stats.defense);s.applyDamage(o.id,n)})}},We={id:"dark_charge",name:"暗影冲锋",description:"向目标冲锋并造成伤害",icon:"/skills/dark_charge.png",mpCost:25,cooldown:3,currentCooldown:0,range:2,type:"active",targetType:"single",effect:(e,t)=>{if(!("stats"in t))return;const s=Math.max(1,e.stats.attack*1.2-t.stats.defense);m().applyDamage(t.id,s)}},Ye={id:"death_curse",name:"死亡诅咒",description:"诅咒目标，降低其攻击和防御",icon:"/skills/death_curse.png",mpCost:40,cooldown:3,currentCooldown:0,range:3,type:"active",targetType:"single",effect:(e,t)=>{"stats"in t&&t.status.push({id:`curse_${Date.now()}`,name:"死亡诅咒",description:"攻击和防御降低25%",icon:"/status/curse.png",duration:2,effect:{type:"debuff",stats:{attack:.25,defense:.25}}})}},te=[{id:"shadow_assassin",name:"暗影刺客",title:"影之追猎者",description:"擅长潜行和突袭的敌方刺客。",avatar:"/enemies/shadow_assassin/avatar.png",portrait:"/enemies/shadow_assassin/portrait.png",tags:[x.ASSASSIN],type:I.WARRIOR,level:1,exp:0,position:{x:0,y:0},stats:{hp:80,maxHp:80,mp:40,maxMp:40,attack:16,defense:3,speed:7},skills:[Q,Be],status:[],isAlly:!1,actionPoints:{...B},maxActionPoints:{move:3,skill:1,item:1}},{id:"dark_mage",name:"暗影法师",title:"暗之编织者",description:"操控黑暗魔法的敌方法师。",avatar:"/enemies/dark_mage/avatar.png",portrait:"/enemies/dark_mage/portrait.png",tags:[x.MAGE],type:I.MAGE,level:1,exp:0,position:{x:0,y:0},stats:{hp:65,maxHp:65,mp:120,maxMp:120,attack:14,defense:2,speed:4},skills:[Q,Ue],status:[],isAlly:!1,actionPoints:{...B},maxActionPoints:{move:2,skill:1,item:1}},{id:"corrupted_knight",name:"堕落骑士",title:"腐化守卫",description:"被黑暗力量腐化的重装骑士。",avatar:"/enemies/corrupted_knight/avatar.png",portrait:"/enemies/corrupted_knight/portrait.png",tags:[x.WARRIOR],type:I.WARRIOR,level:1,exp:0,position:{x:0,y:0},stats:{hp:40,maxHp:40,mp:80,maxMp:80,attack:12,defense:8,speed:3},skills:[Q,We],status:[],isAlly:!1,actionPoints:{...B},maxActionPoints:{move:2,skill:1,item:1}},{id:"death_prophet",name:"死亡先知",title:"死亡编织者",description:"掌握死亡魔法的神秘法师。",avatar:"/enemies/death_prophet/avatar.png",portrait:"/enemies/death_prophet/portrait.png",tags:[x.MAGE,x.SUPPORT],type:I.MAGE,level:1,exp:0,position:{x:0,y:0},stats:{hp:70,maxHp:70,mp:110,maxMp:110,attack:10,defense:4,speed:4},skills:[Q,Ye],status:[],isAlly:!1,actionPoints:{...B},maxActionPoints:{move:2,skill:1,item:1}}];class ze{constructor(t){j(this,"hero");j(this,"boardStore",P());j(this,"heroStore",m());j(this,"gameStore",$());this.hero=t}async executeTurn(){console.log(`[EnemyAI] ${this.hero.name} 开始执行回合`),this.gameStore.regenerateMana(this.hero);const t=this.findNearestTarget();if(!t){console.log(`[EnemyAI] ${this.hero.name} 没有找到目标`);return}console.log(`[EnemyAI] ${this.hero.name} 找到目标: ${t.name}`);const s=this.calculateDistance(this.hero.position,t.position);if(console.log(`[EnemyAI] 与目标距离: ${s}, 行动点数:`,this.hero.actionPoints),this.hero.actionPoints.skill>0&&this.hero.skills.length>0){const o=this.findBestSkill(t);if(o){console.log(`[EnemyAI] ${this.hero.name} 选择技能: ${o.name}`),s>o.range&&this.hero.actionPoints.move>0&&(console.log("[EnemyAI] 技能射程不够，尝试移动接近目标"),await this.moveTowardsTarget(t.position));const n=this.calculateDistance(this.hero.position,t.position);console.log(`[EnemyAI] 移动后与目标距离: ${n}, 技能射程: ${o.range}`),n<=o.range?(console.log(`[EnemyAI] ${this.hero.name} 准备使用技能: ${o.name}`),await this.useSkill(o,t)):console.log("[EnemyAI] 目标仍在射程外，无法使用技能")}else console.log(`[EnemyAI] ${this.hero.name} 没有找到合适的技能`)}else console.log(`[EnemyAI] ${this.hero.name} 没有可用的技能点数或技能列表为空`);this.hero.actionPoints.move>0&&(console.log(`[EnemyAI] ${this.hero.name} 尝试移动接近目标`),await this.moveTowardsTarget(t.position)),this.hero.actionPoints={move:0,skill:0,item:0},console.log(`[EnemyAI] ${this.hero.name} 回合结束`)}findBestSkill(t){const s=this.hero.skills.filter(o=>o.currentCooldown===0&&this.hero.stats.mp>=o.mpCost);return console.log(`[EnemyAI] ${this.hero.name} 可用技能:`,s.map(o=>({name:o.name,cooldown:o.currentCooldown,mpCost:o.mpCost,currentMp:this.hero.stats.mp}))),s[0]}async useSkill(t,s){return console.log(`[EnemyAI] ${this.hero.name} 开始使用技能 ${t.name}`),console.log("[EnemyAI] 技能详情:",{mpCost:t.mpCost,currentMp:this.hero.stats.mp,cooldown:t.cooldown}),new Promise(o=>{setTimeout(()=>{try{t.effect(this.hero,s),t.currentCooldown=t.cooldown,this.hero.stats.mp-=t.mpCost,this.hero.actionPoints.skill=0,console.log(`[EnemyAI] ${this.hero.name} 技能使用完成，剩余MP: ${this.hero.stats.mp}`)}catch(n){console.error("[EnemyAI] 技能使用出错:",n)}o()},500)})}findNearestTarget(){const t=this.heroStore.allies;if(t.length===0)return null;let s=null,o=1/0;return t.forEach(n=>{const i=this.calculateDistance(this.hero.position,n.position);i<o&&(o=i,s=n)}),s}calculateDistance(t,s){return Math.abs(t.x-s.x)+Math.abs(t.y-s.y)}async moveTowardsTarget(t){if(this.hero.actionPoints.move<=0)return;const s=this.boardStore.calculateMovableRange(this.hero.position,this.hero.actionPoints.move);let o=this.hero.position,n=this.calculateDistance(this.hero.position,t);s.forEach(i=>{const r=this.calculateDistance(i,t);r<n&&(n=r,o=i)}),o!==this.hero.position&&await this.move(o)}async move(t){return new Promise(s=>{setTimeout(()=>{this.heroStore.moveHero(this.hero.id,t),this.hero.actionPoints.move=0,s()},500)})}async attack(t){if(!(this.hero.actionPoints.skill<=0))return new Promise(s=>{setTimeout(()=>{const o=Math.max(1,this.hero.stats.attack-t.stats.defense);t.stats.hp=Math.max(0,t.stats.hp-o),this.hero.actionPoints.skill=0,s()},500)})}}const ue={id:"tutorial",name:"初始之地",width:8,height:8,difficulty:1,description:"一片适合初学者的平原地形。",maxTeamSize:4,terrain:[[2,2,2,2,2,2,2,2],[2,0,0,0,0,0,0,2],[2,0,0,0,2,2,0,2],[2,2,0,0,0,0,0,2],[2,0,0,0,0,0,2,2],[2,0,2,2,0,0,0,2],[2,0,0,0,0,0,0,2],[2,2,2,2,2,2,2,2]].map(e=>e.map(t=>{switch(t){case 0:return F.GROUND;case 1:return F.WATER;case 2:return F.WALL;default:return F.GROUND}})),spawnPoints:[{position:{x:1,y:1},type:T.ALLY,isOccupied:!1},{position:{x:2,y:1},type:T.ALLY,isOccupied:!1},{position:{x:1,y:2},type:T.ALLY,isOccupied:!1},{position:{x:2,y:2},type:T.ALLY,isOccupied:!1},{position:{x:5,y:5},type:T.ENEMY,isOccupied:!1},{position:{x:6,y:5},type:T.ENEMY,isOccupied:!1},{position:{x:5,y:6},type:T.ENEMY,isOccupied:!1},{position:{x:6,y:6},type:T.ENEMY,isOccupied:!1}],rewards:{exp:150},enemies:[{id:"shadow_assassin",level:1,position:{x:5,y:5}},{id:"corrupted_knight",level:1,position:{x:5,y:6}}],waves:[]},$=oe("game",{state:()=>({currentTurn:1,isGameStarted:!1,isPaused:!1,playerTeam:[],turnState:{currentHeroId:null,remainingActions:0,turnOrder:[],phase:q.PREPARE,isProcessing:!1},actionPoints:{...K},selectedSkill:null,isGameOver:!1,victoryDialogVisible:!1,heroes:new Map}),getters:{currentHero:e=>{const t=m();return e.turnState.currentHeroId?t.heroes.get(e.turnState.currentHeroId):null},canMove:e=>{const t=e.turnState.currentHeroId?m().heroes.get(e.turnState.currentHeroId):null;return(t==null?void 0:t.actionPoints.move)&&t.actionPoints.move>0},canUseSkill:e=>e.actionPoints.skill>0,canUseItem:e=>e.actionPoints.item>0,hasRemainingActions:e=>e.actionPoints.move>0||e.actionPoints.skill>0||e.actionPoints.item>0},actions:{startGame(){this.isGameStarted=!0,this.currentTurn=1,this.isGameOver=!1,this.victoryDialogVisible=!1;const e=m();e.heroes.clear(),e.deadHeroes.clear(),this.playerTeam=[],this.spawnHeroes(),this.spawnEnemies(),this.initializeTurnOrder()},initializeTurnOrder(){const e=m(),t=Array.from(e.heroes.values()).filter(s=>!e.deadHeroes.has(s.id));console.log(`[Turn Order] Initializing turn order with ${t.length} alive heroes`),this.turnState.turnOrder=t.map(s=>({heroId:s.id,initiative:s.stats.speed+Math.random()*20})).sort((s,o)=>o.initiative-s.initiative),this.turnState.turnOrder.length>0?this.startNewHeroTurn(this.turnState.turnOrder[0].heroId):console.log("[Turn Order] No alive heroes remaining")},async startNewHeroTurn(e){const t=m(),s=P(),o=t.heroes.get(e);if(!o||t.deadHeroes.has(e)){console.log(`[Turn] Skipping turn for dead hero ${e}`),this.endHeroTurn();return}if(console.log(`[Turn] Starting turn for ${o.name}`),this.turnState.isProcessing=!0,this.turnState.currentHeroId=e,this.turnState.phase=q.ACTION,this.selectSkill(null),s.clearSelection(),o.actionPoints={...o.maxActionPoints},t.setActiveHero(e),o.isAlly){if(o.actionPoints.move>0){const n=s.calculateMovableRange(o.position,o.actionPoints.move);s.setSelectableTiles(n),t.selectHero(e)}this.turnState.isProcessing=!1}else try{await new ze(o).executeTurn(),this.turnState.isProcessing=!1,await new Promise(i=>setTimeout(i,500)),this.endHeroTurn()}catch(n){console.error("AI执行出错:",n),this.turnState.isProcessing=!1,this.endHeroTurn()}},endHeroTurn(){if(!this.currentHero||(this.currentHero.skills.forEach(o=>{o.currentCooldown>0&&o.currentCooldown--}),this.turnState.isProcessing))return;this.turnState.isProcessing=!0,this.turnState.phase=q.END;const t=(this.turnState.turnOrder.findIndex(o=>o.heroId===this.turnState.currentHeroId)+1)%this.turnState.turnOrder.length;t===0&&this.currentTurn++;const s=m();s.selectHero(null),s.setActiveHero(null),setTimeout(()=>{this.startNewHeroTurn(this.turnState.turnOrder[t].heroId)},300)},useActionPoint(e){const t=this.currentHero;if(!t||!t.actionPoints[e])return!1;t.actionPoints[e]--;const s=Object.values(t.actionPoints).some(i=>i>0),o=P(),n=m();if(e==="move")if(t.actionPoints.move>0){console.log(`[Action] Hero has ${t.actionPoints.move} move points remaining`);const i=o.calculateMovableRange(t.position,t.actionPoints.move);o.setSelectableTiles(i),n.selectHero(t.id)}else console.log("[Action] No more move points, clearing movement range"),o.clearSelection();return!s&&!this.turnState.isProcessing&&setTimeout(()=>{this.endHeroTurn()},500),!0},spawnHeroes(){var n,i;const e=P(),t=m(),s=((n=e.currentMap)==null?void 0:n.spawnPoints.filter(r=>r.type===T.ALLY&&!r.isOccupied))||[];(i=e.currentMap)==null||i.spawnPoints.forEach(r=>{r.isOccupied=!1}),se.slice(0,4).forEach((r,g)=>{const d=s[g];if(d){const u={...r,position:{...d.position},stats:{...r.stats},actionPoints:{...K},status:[],skills:r.skills.map(c=>({...c,currentCooldown:0}))};t.addHero(u),this.playerTeam.push(r.id),d.isOccupied=!0}})},spawnHero(e,t,s){const o={...e,position:t.position,isAlly:!0};s.heroes.set(o.id,o),t.isOccupied=!0},spawnEnemies(){var o;const e=P(),t=m();(((o=e.currentMap)==null?void 0:o.enemies)||[]).forEach(n=>{const i=te.find(r=>r.id===n.id);if(i){const r={...i,level:n.level,position:n.position,isAlly:!1};t.heroes.set(r.id,r)}})},checkWaveSpawn(){var o,n;const e=P(),t=m(),s=(n=(o=e.currentMap)==null?void 0:o.waves)==null?void 0:n.find(i=>i.turn===this.currentTurn);s&&s.enemies.forEach(i=>{const r=te.find(g=>g.id===i.id);if(r){const g={...r,level:i.level,position:i.position,isAlly:!1};t.heroes.set(g.id,g)}})},endTurn(){this.currentTurn++,this.checkWaveSpawn()},pauseGame(){this.isPaused=!0},resumeGame(){this.isPaused=!1},resetGame(){this.currentTurn=1,this.isGameStarted=!1,this.isPaused=!1,this.playerTeam=[]},selectSkill(e){this.selectedSkill=e},async useSkill(e){const t=this.currentHero,s=this.selectedSkill;return!t||!s||s.currentCooldown>0?!1:(await s.effect(t,e),s.currentCooldown=s.cooldown,t.stats.mp-=s.mpCost,t.actionPoints.skill--,!0)},findTargetAtPosition(e){const t=m();return Array.from(t.heroes.values()).find(s=>s.position.x===e.x&&s.position.y===e.y)||null},findTargetsInRange(e,t){const s=m();return Array.from(s.heroes.values()).filter(o=>Math.abs(o.position.x-e.x)+Math.abs(o.position.y-e.y)<=t)},handleVictory(){console.log("[Game] Victory condition met, showing victory dialog"),this.isGameOver=!0,this.victoryDialogVisible=!0},restartGame(){this.currentTurn=1,this.isGameStarted=!1,this.isPaused=!1,this.playerTeam=[],this.turnState={currentHeroId:null,remainingActions:0,turnOrder:[],phase:q.PREPARE,isProcessing:!1},this.selectedSkill=null,this.victoryDialogVisible=!1,this.isGameOver=!1,this.actionPoints={...K};const e=m(),t=P();e.$reset(),t.$reset(),t.initializeBoard(),t.loadMap(ue),this.startGame()},initializeGame(){const e=m(),s=P().currentMap;s&&(e.heroes.clear(),e.deadHeroes.clear(),se.forEach((o,n)=>{const i=s.spawnPoints.find(r=>r.type===T.ALLY&&!r.isOccupied);if(i){const r={...o};r.position={...i.position},r.stats={...o.stats},r.actionPoints={...K},r.status=[],e.addHero(r),i.isOccupied=!0}}),s.enemies.forEach(o=>{const n=te.find(i=>i.id===o.id);if(n){const i={...n};i.position={...o.position},i.stats={...n.stats},i.actionPoints={...K},i.status=[],e.addHero(i)}}),this.initializeTurnOrder())},removeFromTurnOrder(e){console.log(`[Turn Order] Removing hero ${e} from turn order`);const t=this.turnState.turnOrder.findIndex(s=>s.heroId===e);if(t!==-1){if(this.turnState.turnOrder=this.turnState.turnOrder.filter(s=>s.heroId!==e),console.log("[Turn Order] Updated turn order:",this.turnState.turnOrder.map(s=>s.heroId)),this.turnState.turnOrder.length===0){console.log("[Turn Order] No units remaining in turn order");return}if(this.turnState.currentHeroId===e){const s=t%this.turnState.turnOrder.length,o=this.turnState.turnOrder[s].heroId;console.log(`[Turn Order] Starting next hero's turn: ${o}`),this.startNewHeroTurn(o)}}},useActionPoints(e,t=1){const s=this.currentHero;return s&&s.actionPoints[e]>=t?(s.actionPoints[e]-=t,!0):!1},regenerateMana(e){const t=Math.floor(e.stats.maxMp*.3);e.stats.mp=Math.min(e.stats.maxMp,e.stats.mp+t),console.log(`[Mana] ${e.name} 回复了 ${t} 点魔法值，当前: ${e.stats.mp}/${e.stats.maxMp}`)},startHeroTurn(e){const t=this.heroes.get(e);t&&this.regenerateMana(t)}}}),Xe={class:"turn-indicator"},Fe={class:"current-turn"},je={class:"turn-order"},Ke=["src","alt","title"],qe={key:0,class:"action-points"},Je=D({__name:"TurnIndicator",setup(e){const t=$(),s=m(),o=A(()=>t.currentTurn),n=A(()=>t.turnState),i=A(()=>t.currentHero),r=u=>{var c;return((c=s.heroes.get(u))==null?void 0:c.avatar)||""},g=u=>{var c;return((c=s.heroes.get(u))==null?void 0:c.name)||""},d=u=>{var c;return((c=s.heroes.get(u))==null?void 0:c.isAlly)||!1};return(u,c)=>(h(),y("div",Xe,[l("div",Fe," 回合 "+w(o.value),1),l("div",je,[E(He,{name:"hero-order"},{default:O(()=>[(h(!0),y(W,null,Y(n.value.turnOrder,p=>(h(),y("div",{key:p.heroId,class:H(["hero-order",{active:p.heroId===n.value.currentHeroId,ally:d(p.heroId)}])},[l("img",{src:r(p.heroId),alt:g(p.heroId),title:g(p.heroId)},null,8,Ke)],2))),128))]),_:1})]),i.value?(h(),y("div",qe,[l("div",{class:H(["point move",{used:!i.value.actionPoints.move}])},[l("span",null,"移动 ("+w(i.value.actionPoints.move)+"/"+w(i.value.maxActionPoints.move)+")",1)],2),l("div",{class:H(["point skill",{used:!i.value.actionPoints.skill}])},[l("span",null,"技能 ("+w(i.value.actionPoints.skill)+"/"+w(i.value.maxActionPoints.skill)+")",1)],2),l("div",{class:H(["point item",{used:!i.value.actionPoints.item}])},[l("span",null,"道具 ("+w(i.value.actionPoints.item)+"/"+w(i.value.maxActionPoints.item)+")",1)],2)])):R("",!0)]))}});const Qe=N(Je,[["__scopeId","data-v-99b0bd2b"]]),Ze=D({__name:"Tooltip",props:{content:{},position:{},delay:{}},setup(e){const t=e,s=z(!1);let o=null;const n=()=>{o&&clearTimeout(o),o=setTimeout(()=>{s.value=!0},t.delay||200)},i=()=>{o&&clearTimeout(o),s.value=!1};return(r,g)=>(h(),y("div",{class:"tooltip-container",onMouseenter:n,onMouseleave:i},[U(r.$slots,"default",{},void 0,!0),E(ce,{name:"tooltip"},{default:O(()=>[s.value?(h(),y("div",{key:0,class:H(["tooltip",r.position])},w(r.content),3)):R("",!0)]),_:1})],32))}});const et=N(Ze,[["__scopeId","data-v-e4d99a3d"]]),tt={class:"skill-bar"},st={class:"skill-list"},ot=["onClick"],nt={class:"skill-icon"},it=["src","alt"],at={key:0,class:"cooldown-overlay"},rt={class:"skill-info"},lt={class:"skill-name"},ct={class:"skill-cost"},dt=D({__name:"SkillBar",setup(e){const t=$(),s=P(),o=A(()=>{var d;return((d=t.currentHero)==null?void 0:d.skills)||[]}),n=A(()=>t.selectedSkill),i=d=>{const u=t.currentHero;return u?d.currentCooldown===0&&u.stats.mp>=d.mpCost&&u.actionPoints.skill>0:!1},r=d=>{var p;if(!i(d))return;if(((p=n.value)==null?void 0:p.id)===d.id){t.selectSkill(null),s.clearSelection();return}t.selectSkill(d);const u=t.currentHero,c=g(u.position,d);s.setSelectableTiles(c)},g=(d,u)=>{const c=[],p=u.range;switch(u.targetType){case"single":for(let S=-p;S<=p;S++)for(let b=-p;b<=p;b++)if(Math.abs(S)+Math.abs(b)<=p){const C={x:d.x+S,y:d.y+b};s.isValidPosition(C)&&c.push(C)}break;case"area":for(let S=-p;S<=p;S++)for(let b=-p;b<=p;b++)if(Math.abs(S)+Math.abs(b)<=p){const C={x:d.x+S,y:d.y+b};s.isValidPosition(C)&&c.push(C)}break;case"self":c.push(d);break}return c};return(d,u)=>(h(),y("div",tt,[l("div",st,[(h(!0),y(W,null,Y(o.value,c=>{var p;return h(),y("div",{key:c.id,class:H(["skill-item",{disabled:!i(c),selected:((p=n.value)==null?void 0:p.id)===c.id}]),onClick:S=>r(c)},[l("div",nt,[l("img",{src:c.icon,alt:c.name},null,8,it),c.currentCooldown>0?(h(),y("div",at,w(c.currentCooldown),1)):R("",!0)]),l("div",rt,[l("div",lt,w(c.name),1),l("div",ct,"MP: "+w(c.mpCost),1)]),E(et,{content:c.description,position:"top"},{default:O(()=>u[0]||(u[0]=[l("div",{class:"info-icon"},"?",-1)])),_:2},1032,["content"])],10,ot)}),128))])]))}});const ut=N(dt,[["__scopeId","data-v-34280043"]]),ht={class:"dialog-header"},pt={class:"dialog-body"},mt={key:0,class:"dialog-footer"},ft=D({__name:"Dialog",props:{modelValue:{type:Boolean},title:{},closeOnOverlay:{type:Boolean}},emits:["update:modelValue"],setup(e,{emit:t}){const s=e,o=t,n=()=>{s.closeOnOverlay&&o("update:modelValue",!1)};return(i,r)=>(h(),Z(Te,{to:"body"},[E(ce,{name:"dialog-fade"},{default:O(()=>[i.modelValue?(h(),y("div",{key:0,class:"dialog-overlay",onClick:n},[l("div",{class:"dialog-content",onClick:r[1]||(r[1]=de(()=>{},["stop"]))},[l("div",ht,[U(i.$slots,"header",{},()=>[l("h3",null,w(i.title),1)],!0),l("button",{class:"close-button",onClick:r[0]||(r[0]=g=>i.$emit("update:modelValue",!1))}," × ")]),l("div",pt,[U(i.$slots,"default",{},void 0,!0)]),i.$slots.footer?(h(),y("div",mt,[U(i.$slots,"footer",{},void 0,!0)])):R("",!0)])])):R("",!0)]),_:3})]))}});const vt=N(ft,[["__scopeId","data-v-87625d2a"]]),gt=["disabled"],yt=D({__name:"Button",props:{variant:{},disabled:{type:Boolean}},emits:["click"],setup(e){return(t,s)=>(h(),y("button",{class:H(["game-button",[t.variant,{disabled:t.disabled}]]),disabled:t.disabled,onClick:s[0]||(s[0]=o=>t.$emit("click"))},[U(t.$slots,"default",{},void 0,!0)],10,gt))}});const le=N(yt,[["__scopeId","data-v-dfc362eb"]]),_t={class:"game-layout"},St={class:"floating-turn-controls"},kt={class:"turn-info"},wt={class:"game-main"},bt={class:"board-viewport"},xt={class:"action-content"},Pt={class:"skill-bar-container"},At={class:"turn-buttons"},Ht=["disabled"],Tt={class:"victory-dialog"},$t={class:"dialog-buttons"},Mt=D({__name:"GameLayout",setup(e){const t=$(),s=$e(),o=z(!0),n=A(()=>{const d=t.currentHero;return(d==null?void 0:d.isAlly)??!1}),i=()=>{t.endHeroTurn()},r=()=>{t.restartGame()},g=()=>{t.restartGame(),s.push("/")};return(d,u)=>{var c,p;return h(),y("div",_t,[l("div",St,[l("div",kt,[E(Qe)])]),l("main",wt,[l("div",bt,[U(d.$slots,"board",{},void 0,!0)]),l("aside",{class:H(["info-panel",{show:o.value}])},[U(d.$slots,"character-info",{},void 0,!0),U(d.$slots,"skill-panel",{},void 0,!0)],2)]),l("div",{class:H(["action-panel",{show:(c=L(t).currentHero)==null?void 0:c.isAlly}])},[l("div",xt,[l("div",Pt,[(p=L(t).currentHero)!=null&&p.isAlly?(h(),Z(ut,{key:0})):R("",!0),l("div",At,[l("button",{class:"turn-btn skip-turn-btn",onClick:i,disabled:!n.value},u[1]||(u[1]=[l("span",null,"结束回合",-1)]),8,Ht)])])])],2),E(vt,{modelValue:L(t).victoryDialogVisible,"onUpdate:modelValue":u[0]||(u[0]=S=>L(t).victoryDialogVisible=S),title:"胜利！",closeOnOverlay:!1},{default:O(()=>[l("div",Tt,[u[4]||(u[4]=l("h2",null,"恭喜你取得胜利！",-1)),u[5]||(u[5]=l("p",null,"你成功击败了所有敌人。",-1)),l("div",$t,[E(le,{onClick:r},{default:O(()=>u[2]||(u[2]=[re("重新开始")])),_:1}),E(le,{onClick:g,variant:"secondary"},{default:O(()=>u[3]||(u[3]=[re("返回主菜单")])),_:1})])])]),_:1},8,["modelValue"])])}}});const Ct=N(Mt,[["__scopeId","data-v-4aa37e1f"]]),Et=()=>{const e=z({isPressed:!1,startPosition:null,currentPosition:null});return{mouseState:e,handleMouseDown:n=>{e.value.isPressed=!0,e.value.startPosition=n,e.value.currentPosition=n},handleMouseMove:n=>{e.value.isPressed&&(e.value.currentPosition=n)},handleMouseUp:()=>{e.value.isPressed=!1,e.value.startPosition=null,e.value.currentPosition=null}}},It={class:"hero-portrait"},Ot=["src","alt"],Rt={class:"hero-info"},Dt={class:"hero-hp-bar"},Nt={class:"hero-mp-bar"},Gt={class:"status-effects"},Vt=["title"],Lt=["src","alt"],Bt=D({__name:"HeroUnit",props:{hero:{}},emits:["click","tile-click"],setup(e,{emit:t}){const s=e,o=t,n=()=>{const c=m(),p=P();if(c.deadHeroes.has(s.hero.id)){console.log(`[Click] Ignoring click on dead hero ${s.hero.name}`);return}if(console.log(`[Click] Hero clicked: ${s.hero.name}`),$().selectedSkill){console.log("[Click] Has selected skill, simulating tile click");const b={position:s.hero.position,type:p.tiles[s.hero.position.y][s.hero.position.x].type,isWalkable:!0,isOccupied:!0};o("tile-click",b)}else o("click",s.hero)},i=$();P();const r=A(()=>s.hero.id===i.turnState.currentHeroId),g=A(()=>({"--unit-x":`${s.hero.position.x*80}px`,"--unit-y":`${s.hero.position.y*80}px`,"--unit-z":r.value?"1":"0"})),d=m(),u=A(()=>d.deadHeroes.has(s.hero.id));return(c,p)=>(h(),y("div",{class:H(["hero-unit",[c.hero.isAlly?"ally":"enemy",{active:r.value,dead:u.value}]]),style:J(g.value),onClick:de(n,["stop"])},[l("div",It,[l("img",{src:c.hero.avatar,alt:c.hero.name},null,8,Ot)]),l("div",Rt,[l("div",Dt,[l("div",{class:"hp-fill",style:J({width:`${c.hero.stats.hp/c.hero.stats.maxHp*100}%`})},null,4)]),l("div",Nt,[l("div",{class:"mp-fill",style:J({width:`${c.hero.stats.mp/c.hero.stats.maxMp*100}%`,transition:"width 0.5s ease-out"})},null,4)])]),l("div",Gt,[(h(!0),y(W,null,Y(c.hero.status,S=>(h(),y("div",{key:S.id,class:"status-icon",title:S.name},[l("img",{src:S.icon,alt:S.name},null,8,Lt)],8,Vt))),128))])],6))}});const Ut=N(Bt,[["__scopeId","data-v-d7635fa0"]]),Wt={class:"board-grid"},Yt=["onClick","onMouseenter","onMousedown","onMouseup"],zt={class:"tile-content"},Xt={key:0,class:"unit-indicator"},Ft={key:1,class:"selection-indicator"},jt={class:"spawn-points"},Kt={class:"units-layer"},qt=D({__name:"GameBoard",setup(e){Me(a=>({"4fee223d":L(t).height,"09b1bc20":L(t).width}));const t=P(),s=m(),o=$(),n=A(()=>t.currentMap),i=A(()=>Array.from(s.heroes.values())),{mouseState:r,handleMouseDown:g,handleMouseMove:d,handleMouseUp:u}=Et(),c=z(null);t.initializeBoard();const p=A(()=>({"--board-width":`${t.width*80}px`,"--board-height":`${t.height*80}px`})),S=a=>t.highlightedTiles.some(f=>f.x===a.x&&f.y===a.y),b=a=>t.selectableTiles.some(f=>f.x===a.x&&f.y===a.y),C=a=>{var f,k;return((f=t.selectedTile)==null?void 0:f.x)===a.x&&((k=t.selectedTile)==null?void 0:k.y)===a.y},he=a=>{var f,k;return((f=c.value)==null?void 0:f.x)===a.x&&((k=c.value)==null?void 0:k.y)===a.y},ie=async a=>{const f=$(),k=m();if(f.selectedSkill){if(console.log("当前选中技能:",f.selectedSkill.name),b(a.position)){console.log("目标位置在可选范围内:",a.position);const v=xe(a);if(console.log("获取到的技能目标:",v),v){const _=await f.useSkill(v);console.log("技能使用结果:",_),t.clearSelection();return}}else console.log("目标位置不在可选范围内:",a.position);return}else{const v=k.selectedHero;if(v&&b(a.position)){const _=Math.abs(v.position.x-a.position.x)+Math.abs(v.position.y-a.position.y);if(v.actionPoints.move>=_)if(await k.moveHero(v.id,a.position),f.useActionPoints("move",_),v.actionPoints.move>0){const M=t.calculateMovableRange(a.position,v.actionPoints.move);t.setSelectableTiles(M)}else t.clearSelection(),k.selectHero(null)}else C(a.position)&&(t.clearSelection(),k.selectHero(null))}},pe=a=>{c.value=a.position,d(a.position)},me=a=>{g(a.position)},fe=a=>{u()},ve=a=>{if(console.log("Hero clicked:",a),a.id===o.turnState.currentHeroId&&a.isAlly&&(console.log("Valid hero selected"),s.selectHero(a.id),a.actionPoints.move>0)){console.log("Calculating movable range");const f=t.calculateMovableRange(a.position,a.actionPoints.move);console.log("Movable positions:",f),t.setSelectableTiles(f)}},ge=(a,f)=>Math.abs(a.x-f.x)+Math.abs(a.y-f.y),G=z({x:0,y:0}),X=z(!1),V=z({x:0,y:0}),ye=a=>{(a.button===1||a.button===0)&&(X.value=!0,V.value={x:a.clientX,y:a.clientY})},_e=a=>{if(X.value){const f=a.clientX-V.value.x,k=a.clientY-V.value.y;G.value.x+=f,G.value.y+=k,V.value={x:a.clientX,y:a.clientY}}},ae=()=>{X.value=!1},Se=a=>{a.preventDefault(),G.value.x-=a.deltaX,G.value.y-=a.deltaY},ke=a=>{a.touches.length===1&&(X.value=!0,V.value={x:a.touches[0].clientX,y:a.touches[0].clientY})},we=a=>{if(X.value&&a.touches.length===1){const f=a.touches[0].clientX-V.value.x,k=a.touches[0].clientY-V.value.y;G.value.x+=f,G.value.y+=k,V.value={x:a.touches[0].clientX,y:a.touches[0].clientY}}},be=()=>{X.value=!1},xe=a=>{const f=$(),k=m(),v=f.selectedSkill;if(!v)return null;switch(console.log("技能类型:",v.targetType),v.targetType){case"single":const _=Array.from(k.heroes.values()).find(M=>M.position.x===a.position.x&&M.position.y===a.position.y);return console.log("找到的单体目标:",_),_;case"area":return Array.from(k.heroes.values()).filter(M=>ge(a.position,M.position)<=(v.aoeRange||1));case"position":return a.position;case"self":return f.currentHero;default:return null}};return(a,f)=>{var k;return h(),y("div",{class:"game-board-container",onMousedown:ye,onMousemove:_e,onMouseup:ae,onMouseleave:ae,onWheel:Se,onTouchstart:ke,onTouchmove:we,onTouchend:be},[l("div",{class:"game-board",style:J({...p.value,transform:`translate(${G.value.x}px, ${G.value.y}px)`})},[l("div",Wt,[(h(!0),y(W,null,Y(L(t).tiles,v=>(h(),y("div",{key:v[0].position.y,class:"board-row"},[(h(!0),y(W,null,Y(v,_=>(h(),y("div",{key:`${_.position.x}-${_.position.y}`,class:H(["board-tile",[L(ne)[_.type].className,{highlighted:S(_.position),selectable:b(_.position),selected:C(_.position),hover:he(_.position)}]]),onClick:M=>ie(_),onMouseenter:M=>pe(_),onMousedown:M=>me(_),onMouseup:M=>fe()},[l("div",zt,[_.isOccupied?(h(),y("div",Xt)):R("",!0),C(_.position)?(h(),y("div",Ft)):R("",!0)])],42,Yt))),128))]))),128))]),l("div",jt,[(h(!0),y(W,null,Y((k=n.value)==null?void 0:k.spawnPoints,v=>(h(),y("div",{key:`${v.position.x}-${v.position.y}`,class:H(["spawn-indicator",[v.type,{occupied:v.isOccupied}]]),style:J({left:`${v.position.x*80}px`,top:`${v.position.y*80}px`})},null,6))),128))]),l("div",Kt,[(h(!0),y(W,null,Y(i.value,v=>(h(),Z(Ut,{key:v.id,hero:v,onClick:_=>ve(v),onTileClick:ie},null,8,["hero","onClick"]))),128))])],4)],32)}}});const Jt=N(qt,[["__scopeId","data-v-329a13b1"]]),Qt={class:"board-container"},Zt={class:"map-info"},es={key:0,class:"hero-info"},ts={class:"stats"},ss=D({__name:"GameView",setup(e){const t=P(),s=$(),o=A(()=>t.currentMap),n=A(()=>s.currentHero);return Ce(()=>{t.loadMap(ue),s.startGame()}),(i,r)=>(h(),Z(Ct,null,{board:O(()=>[l("div",Qt,[E(Jt)])]),"character-info":O(()=>{var g,d;return[l("div",Zt,[l("h3",null,w((g=o.value)==null?void 0:g.name),1),l("p",null,w((d=o.value)==null?void 0:d.description),1)]),n.value?(h(),y("div",es,[l("h3",null,w(n.value.name),1),l("p",null,w(n.value.title),1),l("div",ts,[l("div",null,"HP: "+w(n.value.stats.hp)+"/"+w(n.value.stats.maxHp),1),l("div",null,"MP: "+w(n.value.stats.mp)+"/"+w(n.value.stats.maxMp),1)])])):R("",!0)]}),_:1}))}});const rs=N(ss,[["__scopeId","data-v-87f27816"]]);export{rs as default};
